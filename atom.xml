<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mysry</title>
  
  <subtitle>Life is short, learn more!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.mysry.com/"/>
  <updated>2018-04-23T05:44:32.160Z</updated>
  <id>http://www.mysry.com/</id>
  
  <author>
    <name>Mysry</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>123. Best Time to Buy and Sell Stock III</title>
    <link href="http://www.mysry.com/2018/04/23/123-Best-Time-to-Buy-and-Sell-Stock-III/"/>
    <id>http://www.mysry.com/2018/04/23/123-Best-Time-to-Buy-and-Sell-Stock-III/</id>
    <published>2018-04-23T03:14:38.000Z</published>
    <updated>2018-04-23T05:44:32.160Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目">题目</h2><p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/description/" target="_blank" rel="external">Best Time to Buy and Sell Stock III</a></p><h2 id="解题思路">解题思路</h2><p>  我们首先把这题扩展到最多售卖k次的情况，然后把k设置为2,还是使用局部最优和全局最优的分析方法。我们全局更新两种变量，一个是到达当前第i天，最多进行j次交易，最好的利润global[i][j]，一个是当前第i天，最多可以进行j次交易，且最后一次交易在当天卖出的最好利润local[i][j]，现在来考虑动态方程:<span class="math display">\[global[i][j]=max(local[i][j],global[i-1][j])\]</span>，也就是把当前局部最好的和过往全局最好的最大的进行比较（最后一次交易如果包含当前天一定在局部最好里，否则一定在过往全局最优里）。<span class="math display">\[local[i][j]=max(global[i-1][j-1]+max(diff,0),local[i-1][j]+diff)\]</span>也是看两个量，第一个是全局i-1天进行j-1次交易，加上今天的交易量，如果今天是赚钱的话（也就是前面只要j-1次交易，最后一次交易取当前天），第二个量则是取local第i-1天j次交易，然后加上今天的差值（这里因为local[i-1][j]比如包含第i-1天卖出的交易，所以现在变成第i天卖出，并不会增加交易次数，而且这里无论diff是不是大于0都一定要加上，因为否则就不满足local[i][j]必须在最后一天卖出的条件了）。   上面的算法中对于天数需要一次扫描，而每次要对交易次数进行递推式求解，所以时间复杂度是O(n*k)，如果是最多进行两次交易，那么复杂度还是O(n)。空间上只需要维护当天数据皆可以，所以是O(k)，当k=2，则是O(1)。</p><h2 id="java-code">Java Code</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">    public int maxProfit(int[] prices) &#123;</div><div class="line">        if(prices==null||prices.length==0)</div><div class="line">            return 0;</div><div class="line">        int[] local = new int[3];</div><div class="line">        int[] global = new int[3];</div><div class="line">        for(int i = 0;i&lt;prices.length-1;i++)&#123;</div><div class="line">            int diff = prices[i+1]-prices[i];</div><div class="line">            for(int j = 2;j&gt;=1;j--)&#123;</div><div class="line">                local[j] = Math.max(global[j-1]+(diff&gt;0?diff:0), local[j]+diff);  </div><div class="line">                global[j] = Math.max(local[j],global[j]);  </div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return global[2];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="c-code">C++ Code</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int maxProfit(vector&lt;int&gt;&amp; prices) &#123;</div><div class="line">        if(prices.empty())</div><div class="line">            return 0;</div><div class="line">        vector&lt;int&gt;locale(3,0);</div><div class="line">        vector&lt;int&gt;global(3,0);</div><div class="line">        for(int i = 0; i&lt; prices.size()-1;i++)&#123;</div><div class="line">            int diff = prices[i+1]-prices[i];</div><div class="line">            for(int j = 2;j &gt;= 1;j--)&#123;</div><div class="line">                locale[j] = max(global[j-1] + (diff&gt;0?diff:0), locale[j] + diff);</div><div class="line">                global[j] = max(locale[j], global[j]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return global[2];</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;题目&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/description/&quot; target=&quot;_blank&quot; rel=&quot;externa
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://www.mysry.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>120. Triangle</title>
    <link href="http://www.mysry.com/2018/04/11/120-Triangle/"/>
    <id>http://www.mysry.com/2018/04/11/120-Triangle/</id>
    <published>2018-04-11T13:12:46.000Z</published>
    <updated>2018-04-23T03:14:11.283Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目">题目</h2><p>Triangle(https://leetcode.com/problems/triangle/description/)</p><h2 id="思路">思路</h2><p>  本题是典型的二维动态规划问题，采取自下而上的遍历方法，最后返回dp[0][0]即为所求，每一层的最短路径都是前一层的加上前一层左边或右边的数字<span class="math display">\[triangle[i][j] += min(triangle[i+1][j+1],triangle[i+1][j])\]</span></p><h2 id="java-code">Java Code:</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">    public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) &#123;</div><div class="line">        int[] res = new int[triangle.size()+1];</div><div class="line">        for(int i = triangle.size()-1;i&gt;=0;i--)&#123;</div><div class="line">            for(int j = 0; j &lt; triangle.get(i).size() ;j++)&#123;</div><div class="line">                res[j] = Math.min(res[j],res[j+1]) + triangle.get(i).get(j);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return res[0];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="c-code">C++ Code:</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; triangle)&#123;</div><div class="line">        for(int i = triangle.size()-2;i &gt;= 0;--i)&#123;</div><div class="line">            for(int j = 0;j &lt;= i;++j)&#123;</div><div class="line">                triangle[i][j] += min(triangle[i+1][j+1],triangle[i+1][j]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return triangle[0][0];</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;题目&lt;/h2&gt;
&lt;p&gt;Triangle(https://leetcode.com/problems/triangle/description/)&lt;/p&gt;
&lt;h2 id=&quot;思路&quot;&gt;思路&lt;/h2&gt;
&lt;p&gt;  本题是典型的二维动态规划问题，采取自下而上的遍历方法
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://www.mysry.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>约瑟夫环</title>
    <link href="http://www.mysry.com/2018/04/03/%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF/"/>
    <id>http://www.mysry.com/2018/04/03/约瑟夫环/</id>
    <published>2018-04-03T11:56:57.000Z</published>
    <updated>2018-04-03T12:48:40.686Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题引入">问题引入</h2><p>  约瑟夫环：已知n个人（编号0,1,…,n-1）围成一个圆环，从0开始报数，数到第m-1个出列，他的下一个又从0开始报数，数到m-1的那个人出列，求最后一个人的编号。</p><h2 id="解法思路">解法思路</h2><p>  在第一个人被踢出以后，剩下的n-1个人组成一个新的约瑟夫环，以编号为k=m%n的人开始：k,k+1,…,n-2,n-1,0,1,…,k-2,那么我们对他们的编号做一下转换： <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">k    --&gt; 0</div><div class="line">k+1  --&gt; 1</div><div class="line">   ...</div><div class="line">k-2  --&gt; n-2</div><div class="line">k-1  --&gt; n-1(踢出)</div></pre></td></tr></table></figure></p><p>变换完就成了n-1的约瑟夫环，假设x为该子问题的最终解，那么逆变环上式，可以求得n个人情况的解，其逆变换公式：x’=(x+k)%n,即要求n个人的解，先求得n-1个人的解，要求n-2的解，则先求n-3的情况，下面给出递推公式：<span class="math display">\[\begin{align}f[1]&amp;=0\\f[i]&amp;=(f[i-1]+m)%i\;\;i&gt;1\end{align}\]</span></p><h2 id="c-code">C++ Code</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">int Josephus(int n, int m)&#123;</div><div class="line">    int i = 0;</div><div class="line">    int s = 0;</div><div class="line">    for(i = 2;i &lt;= n; i++)&#123;</div><div class="line">        s=(s+m)%i;</div><div class="line">    &#125;</div><div class="line">    return s;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;问题引入&quot;&gt;问题引入&lt;/h2&gt;
&lt;p&gt;  约瑟夫环：已知n个人（编号0,1,…,n-1）围成一个圆环，从0开始报数，数到第m-1个出列，他的下一个又从0开始报数，数到m-1的那个人出列，求最后一个人的编号。&lt;/p&gt;
&lt;h2 id=&quot;解法思路&quot;&gt;解法思路&lt;/h2&gt;

      
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://www.mysry.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>KMP算法</title>
    <link href="http://www.mysry.com/2018/04/02/KMP%E7%AE%97%E6%B3%95/"/>
    <id>http://www.mysry.com/2018/04/02/KMP算法/</id>
    <published>2018-04-02T03:03:24.000Z</published>
    <updated>2018-04-02T13:49:26.577Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题引入">问题引入</h2><p>  字符串的模式匹配（字符串定位）是字符串处理最长见的运算。给定两个字符串S和T，在S中找出可能存在的T，并返回T在S中的位置，称T为子串，S为主串。   解决这个问题最简单的思路是暴力匹配的方法（即朴素模式匹配算法），如果用暴力匹配的思路，并且假设现在串S匹配到i位置，串T匹配到j位置，那么;<br> * 如果当前字符匹配成功（s[i]==t[j]），则i++，j++，继续匹配下一字符;<br> * 如果匹配失败（即s[i]!=t[j]）,令i=i+1-j，j=0,相当于每次匹配失败时，i回溯，j置0;<br> 上述过程C++实现如下; <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">int NavieSearch(char* s, char* t)&#123;</div><div class="line">    int m = strlen(s);</div><div class="line">    int n = strlen(t);</div><div class="line"></div><div class="line">    int i = 0;</div><div class="line">    int j = 0;</div><div class="line">    while(i &lt; m &amp;&amp; j &lt; n)&#123;</div><div class="line">        if(s[i]==t[j])&#123;</div><div class="line">            i++;j++;    </div><div class="line">        &#125;</div><div class="line">        else&#123;</div><div class="line">            i = i+1-j;</div><div class="line">            j = 0;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    if(j=n)</div><div class="line">        return i-j;</div><div class="line">    else</div><div class="line">        return -1</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="kmp算法">KMP算法</h2>  Knuth-Morris-Pratt字符串查找算法，简称为“KMP算法”，常用于在一个文本串S内查找一个模式串P 的出现位置，这个算法由Donald Knuth、Vaughan Pratt、James H. Morris三人联合发表。 算法流程：<br> 假设现在串S匹配到i位置，串t匹配到j位置<br>   (1)如果j=-1，或者当前字符匹配成功，（即s[i]==t[j]），都令i++,j++，继续匹配下一字符;<br>   如果j != -1，且当前字符匹配失败（即S[i] != P[j]），则令 i 不变，j = next[j]。此举意味着失配时，模式串T相对于串S向右移动了j - next [j] 位;换言之，当匹配失败时，模式串向右移动的位数为：失配字符所在位置 - 失配字符对应的next值，即移动的实际位数为：j - next[j]，且此值大于等于1。next数组存储当前字符之前的字符串中，相同前后缀的长度;<span class="math display">\[\begin{equation}f(x)=\left\{\begin{aligned}0\;\; &amp; j=1 \\1\;\; &amp; j=2或j&gt;2且不存在满足条件的前缀子串 \\k+1\;\;&amp;j&gt;2且k为满足条件的最长前缀子串的长度\end{aligned}\right.\end{equation}\]</span><p>该数组用来指示每次匹配失败时应该回溯的位置。 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">void GetNext(char* t, int next[])&#123;</div><div class="line">    int n = strlen(t);</div><div class="line">    next[0] = -1;</div><div class="line">    int k = -1;</div><div class="line">    int j = 0;</div><div class="line">    while(j &lt; n-1)&#123;</div><div class="line">        if(k == -1 || t[j] == t[k])&#123;</div><div class="line">            ++k; </div><div class="line">            ++j;</div><div class="line">        &#125;</div><div class="line">        else&#123;</div><div class="line">            k = next[k];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">int KMPSearch(char* s, char* t)&#123;</div><div class="line">    int i = 0;</div><div class="line">    int j = 0;</div><div class="line">    int m = strlen(s);</div><div class="line">    int n = strlen(t);</div><div class="line">    while(i &lt; m &amp;&amp; j&lt;n )&#123;</div><div class="line">        if(j == -1 || s[i] == t[j])&#123;</div><div class="line">            i++;</div><div class="line">            j++;</div><div class="line">        &#125;</div><div class="line">        else&#123;</div><div class="line">            j = next[j];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    if (j == n)</div><div class="line">        return i-j;</div><div class="line">    else</div><div class="line">        return -1;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;问题引入&quot;&gt;问题引入&lt;/h2&gt;
&lt;p&gt;  字符串的模式匹配（字符串定位）是字符串处理最长见的运算。给定两个字符串S和T，在S中找出可能存在的T，并返回T在S中的位置，称T为子串，S为主串。   解决这个问题最简单的思路是暴力匹配的方法（即朴素模式匹配算法），如果用
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://www.mysry.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>115. Distinct Subsequences</title>
    <link href="http://www.mysry.com/2018/04/01/115-Distinct-Subsequences/"/>
    <id>http://www.mysry.com/2018/04/01/115-Distinct-Subsequences/</id>
    <published>2018-04-01T03:18:18.000Z</published>
    <updated>2018-04-01T03:36:26.263Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目">题目</h2><p>Distinct Subsequences(https://leetcode.com/problems/distinct-subsequences/description/)</p><h2 id="解题思路">解题思路</h2><p>  这题大致的意思是给两个字符串S和T，S可以删除它的任意字符，但是不能改变字符的位置，问有多少种方法可以使的S变成T。这是一个动态规划问题，构建dp[i][j]初始T为空字符串时，S为任意字符串都能匹配一次，所以dp[i][0]=1，如果S[i]==T[j]，那么有两种情况，若S[i-1]与T[i-1]匹配，可以选择S[i]与T[j]匹配，如果S[i-1]和T[j]匹配，则删除s[i]，把两种情况和到一起即为dp[i][j]=dp[i][j-1]+(t[i-1]==s[j-1]?dp[i-1][j-1]:0)</p><h2 id="java-code">Java Code</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">    public int numDistinct(String s, String t) &#123;</div><div class="line">        int m = t.length(), n = s.length();</div><div class="line">        int[][] dp = new int[m+1][n+1];</div><div class="line">        for(int i = 0;i&lt;=n ;i++)&#123;</div><div class="line">            dp[0][i]=1;</div><div class="line">        &#125;</div><div class="line">        for(int i = 1;i&lt;=m;i++)&#123;</div><div class="line">            for(int j =1;j&lt;=n;j++)&#123;</div><div class="line">                dp[i][j] = dp[i][j-1]+(t.charAt(i-1)==s.charAt(j-1)?dp[i-1][j-1]:0);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return dp[m][n];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="c-code">C++ Code</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int numDistinct(string s, string t) &#123;</div><div class="line">        int m = t.size(), n = s.size();</div><div class="line">        vector&lt;vector&lt;int&gt;&gt;dp(m+1,vector&lt;int&gt;(n+1,0));</div><div class="line">        for(int i = 0;i&lt;=n;i++)&#123;</div><div class="line">            dp[0][i]=1;</div><div class="line">        &#125;</div><div class="line">        for(int i=1;i&lt;=m;i++)&#123;</div><div class="line">            for(int j=1;j&lt;=n;j++)&#123;</div><div class="line">                dp[i][j] = dp[i][j-1]+(t[i-1]==s[j-1]?dp[i-1][j-1]:0);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return dp[m][n];</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;题目&lt;/h2&gt;
&lt;p&gt;Distinct Subsequences(https://leetcode.com/problems/distinct-subsequences/description/)&lt;/p&gt;
&lt;h2 id=&quot;解题思路&quot;&gt;解题思路&lt;/h2&gt;
&lt;
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://www.mysry.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>647 Palindromic Substrings</title>
    <link href="http://www.mysry.com/2018/03/30/647Palindromic-Substrings/"/>
    <id>http://www.mysry.com/2018/03/30/647Palindromic-Substrings/</id>
    <published>2018-03-30T03:00:30.000Z</published>
    <updated>2018-03-30T03:24:27.258Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目">题目</h2><p>Palindromic Substrings(https://leetcode.com/problems/palindromic-substrings/description/)</p><h2 id="思路">思路</h2><p>  这里提供两种解法，一种是使用递归的解法，一种是使用DP的解法。递归解法：从前往后遍历整个字符串，以遍历的字符为中心向两边扩展，扩展时按字符串长度为奇数和偶数分为两种情况考虑，当字符串长度为偶数时，该字符要和下一字符对比然后扩展，当字符串长度为奇数时，一改字符串为中心向两边扩展直到字符串两边字符串长度不想等。DP解法：构建一个二维bool数组dp[i][j]记录子字符串[i，j]是否为回文字符串，i从n-1往0遍历，j从i往n-1遍历，逐步查看s[i]s[j]是否相等，如果相等，再看i和j的位置，若i、j中间只有一个以下的字符串，则dp[i][j]为true，如果由多余一个字符存在，那么dp[i][j]是否为true要看dp[i+1][j-1]是否为true，在每个使得dp[i][j]为true的位置，res+1。</p><h2 id="java递归解法">Java(递归解法)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">    public int countSubstrings(String s) &#123;</div><div class="line">        if(s==null) return 0;</div><div class="line">        int n = s.length(), res = 0, left =0, right = 0;</div><div class="line">        char[] tmp = s.toCharArray();</div><div class="line">        for(int i=0;i&lt;n;i++)&#123;</div><div class="line">            left = i;</div><div class="line">            right = i;</div><div class="line">            while(left&gt;=0 &amp;&amp; right&lt;s.length() &amp;&amp; tmp[left]==tmp[right])&#123;</div><div class="line">                --left;++right;++res;</div><div class="line">            &#125;</div><div class="line">            left = i;</div><div class="line">            right = i+1;</div><div class="line">            while(left&gt;=0 &amp;&amp; right &lt;s.length() &amp;&amp; tmp[left]==tmp[right])&#123;</div><div class="line">                --left;++right;++res;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return res;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="cdp解法">C++(DP解法)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int countSubstrings(string s) &#123;</div><div class="line">        int n = s.size();</div><div class="line">        vector&lt;vector&lt;bool&gt; &gt;dp(n,vector&lt;bool&gt;(n, false));</div><div class="line">        int res = 0;</div><div class="line">        for(int i = n-1; i&gt;=0;i--)&#123;</div><div class="line">            for(int j = i;j&lt;n;j++)&#123;</div><div class="line">                dp[i][j] = s[i]==s[j] &amp;&amp; (j-i&lt;3 || dp[i+1][j-1]);</div><div class="line">                if(dp[i][j]) &#123;</div><div class="line">                    ++res;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return res;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目&quot;&gt;题目&lt;/h2&gt;
&lt;p&gt;Palindromic Substrings(https://leetcode.com/problems/palindromic-substrings/description/)&lt;/p&gt;
&lt;h2 id=&quot;思路&quot;&gt;思路&lt;/h2&gt;
&lt;p&gt;
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://www.mysry.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>蓄水池抽样算法</title>
    <link href="http://www.mysry.com/2018/03/26/%E8%93%84%E6%B0%B4%E6%B1%A0%E6%8A%BD%E6%A0%B7%E7%AE%97%E6%B3%95/"/>
    <id>http://www.mysry.com/2018/03/26/蓄水池抽样算法/</id>
    <published>2018-03-26T11:54:13.000Z</published>
    <updated>2018-03-27T02:19:29.352Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述">问题描述</h2><p>  从一个大（任意大也行）的数据集中等概率的抽出k个样列，保证抽取结果的公平性。比如:<br> * 从100000份报告中抽取一百份进行分析; * 从Google scholar搜索 “cnn”，从中抽取 100 个结果查看哪些是今年的。</p><p>  既然说到采样问题，最重要的就是做到公平，也就是保证每个元素被采样到的概率是相同的。上述两个问题中，第一个问题非常好解决，再[0,100000-1)内生成1000个随机数，保证不重复即可，但是对于第二个问题这种直观的解法就不能行了，因为我们不知道数据的规模到底有多大。可能有人会想到，我可以先对数据进行一次遍历，计算出数据的数量 NN，然后再按照上述的方法进行采样即可。这当然可以，但是并不好，毕竟这可能需要花上很多时间。也可以尝试估算数据的规模，但是这样得到的采样数据分布可能并不平均。有没有一种合适的算法，完美的解决随机采样的问题呢？</p><h2 id="算法描述">算法描述</h2><p>  我们假设已经有一套非常成熟的随机数算法，带抽样数据集大小为n，采样数为k：<br> (1)构建一个大小为k的数组;<br> (2)初始化改数组为待采样数据集前k个元素;<br> (3)从第k+1个元素开始，以<span class="math inline">\(\frac{k}{n}\)</span>的概率决定该元素是否会被替换到数组中（数组中的元素被替换概率相同），依次遍历完整个数组即为所求。</p><h2 id="数学原理证明">数学原理证明</h2><p>  对于第i个数（i≤k）。在k步之前，被选中的概率为1。当走到第k+1步时，被k+1个元素替换的概率=k+1个元素被选中的概率<em>i被选中替换的概率，即为<span class="math inline">\(\frac{k}{k+1}\times\frac{1}{k}=\frac{1}{k+1}\)</span>。则被保留的概率为<span class="math inline">\(1−\frac{1}{k+1}=\frac{k}{k+1}\)</span>。依次类推，不被k+2个元素替换的概率为<span class="math inline">\(1−\frac{k}{k+2}\times\frac{1}{k}=\frac{k+1}{k+2}\)</span>。则运行到第n步时，被保留的概率=被选中的概率 </em> 不被替换的概率，即：<span class="math display">\[1 \times \frac{k}{k + 1} \times \frac{k + 1}{k + 2} \times \frac{k + 2}{k + 3} \times … \times \frac{n - 1}{n} = \frac{k}{n}\]</span>对于第j个数(j&gt;k)，在第j步被选中的概率为<span class="math inline">\(\frac{k}{j}\)</span>，不被第j+1个元素替换的概率为<span class="math display">\[1 - \frac{k}{j + 1} \times \frac{1}{k} = \frac{j}{j + 1}\]</span>运行到第n步时，被保留的概率 = 被选中的概率 * 不被替换的概率，即：<span class="math display">\[\frac{k}{j} \times \frac{j}{j + 1} \times \frac{j + 1}{j + 2} \times \frac{j + 2}{j + 3} \times ... \times \frac{n - 1}{n} = \frac{k}{n}\]</span>所以对于其中每个元素，被保留的概率都为<span class="math inline">\(\frac{k}{n}\)</span>。</p><h2 id="java-code">Java Code</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"># 没问题</div><div class="line">public class Solution&#123;</div><div class="line">    private Random random = new Random();</div><div class="line">    public int[] sampling(int[]nums, int k)&#123;</div><div class="line">        int n = nums.length;</div><div class="line">        if(n&lt;k) return new int[0];</div><div class="line">        int[] res = new int[k];</div><div class="line">        for(int i= 0;i&lt;k;i++)&#123;</div><div class="line">            res[i] = nums[i];</div><div class="line">        &#125;</div><div class="line">        for(int i = k;i&lt;n;i++)&#123;</div><div class="line">            int r = random.nextInt(i+1);</div><div class="line">            if(r&lt;k)&#123;</div><div class="line">                res[r] = nums[i];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return res;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;问题描述&quot;&gt;问题描述&lt;/h2&gt;
&lt;p&gt;  从一个大（任意大也行）的数据集中等概率的抽出k个样列，保证抽取结果的公平性。比如:&lt;br&gt; * 从100000份报告中抽取一百份进行分析; * 从Google scholar搜索 “cnn”，从中抽取 100 个结果查看哪
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://www.mysry.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>103. Binary Tree Zigzag Level Order Traversal</title>
    <link href="http://www.mysry.com/2018/01/22/103-Binary-Tree-Zigzag-Level-Order-Traversal/"/>
    <id>http://www.mysry.com/2018/01/22/103-Binary-Tree-Zigzag-Level-Order-Traversal/</id>
    <published>2018-01-22T15:16:37.000Z</published>
    <updated>2018-01-22T15:20:28.366Z</updated>
    
    <content type="html"><![CDATA[<h2 id="problem"><font color="black">Problem:</font></h2><blockquote><p>Given a binary tree, return the zigzag level order traversal of its nodes’ values. (ie, from left to right, then right to left for the next level and alternate between).</p></blockquote><h2 id="idea"><font color="red">Idea:</font></h2><p>  For this problem, we need one flag to make it clear the order!</p><h2 id="java-code"><font color="orange">Java Code:</font></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Definition for a binary tree node.</div><div class="line"> * public class TreeNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     TreeNode left;</div><div class="line"> *     TreeNode right;</div><div class="line"> *     TreeNode(int x) &#123; val = x; &#125;</div><div class="line"> * &#125;</div><div class="line"> */</div><div class="line">class Solution &#123;</div><div class="line">    public List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) &#123;</div><div class="line">        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;();</div><div class="line">        Queue&lt;TreeNode&gt;queue = new LinkedList&lt;TreeNode&gt;();</div><div class="line">        if(root==null)</div><div class="line">            return res;</div><div class="line">        queue.add(root);</div><div class="line">        boolean flag = true;</div><div class="line">        while(!queue.isEmpty())&#123;</div><div class="line">            int len = queue.size();</div><div class="line">            List&lt;Integer&gt; tmp = new ArrayList&lt;&gt;();</div><div class="line">            for(int i=0;i&lt;len;i++)&#123;</div><div class="line">                TreeNode node = queue.poll();</div><div class="line">                if(flag)</div><div class="line">                    tmp.add(node.val);</div><div class="line">                else</div><div class="line">                    tmp.add(0,node.val);</div><div class="line">                if(node.left!=null)</div><div class="line">                    queue.add(node.left);</div><div class="line">                if(node.right!=null)</div><div class="line">                    queue.add(node.right);</div><div class="line">            &#125;</div><div class="line">            res.add(tmp);</div><div class="line">            flag = !flag;</div><div class="line">        &#125;</div><div class="line">        return res;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="c-code"><font color="gold">C++ Code:</font></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Definition for a binary tree node.</div><div class="line"> * struct TreeNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     TreeNode *left;</div><div class="line"> *     TreeNode *right;</div><div class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</div><div class="line"> * &#125;;</div><div class="line"> */</div><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    vector&lt;vector&lt;int&gt;&gt; zigzagLevelOrder(TreeNode* root) &#123;</div><div class="line">        vector&lt;vector&lt;int&gt; &gt;res;</div><div class="line">        if(!root)</div><div class="line">            return res;</div><div class="line">        queue&lt;TreeNode*&gt; que;</div><div class="line">        que.push(root);</div><div class="line">        bool ltor = true;</div><div class="line">        while(!que.empty())&#123;</div><div class="line">            int len = que.size();</div><div class="line">            vector&lt;int&gt;tmp(len);</div><div class="line">            for(int i=0;i&lt;len;i++)&#123;</div><div class="line">                TreeNode* node =que.front();</div><div class="line">                que.pop();</div><div class="line">                int idx = ltor?i:len-i-1;</div><div class="line">                tmp[idx] = node-&gt;val;</div><div class="line">                if(node-&gt;left)</div><div class="line">                    que.push(node-&gt;left);</div><div class="line">                if(node-&gt;right)</div><div class="line">                    que.push(node-&gt;right);</div><div class="line">            &#125;</div><div class="line">            ltor = !ltor;</div><div class="line">            res.push_back(tmp);</div><div class="line">        &#125;</div><div class="line">        return res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;problem&quot;&gt;&lt;font color=&quot;black&quot;&gt;Problem:&lt;/font&gt;&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Given a binary tree, return the zigzag level order traversal of it
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://www.mysry.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>102. Binary Tree Level Order Traversal</title>
    <link href="http://www.mysry.com/2018/01/18/102-Binary-Tree-Level-Order-Traversal/"/>
    <id>http://www.mysry.com/2018/01/18/102-Binary-Tree-Level-Order-Traversal/</id>
    <published>2018-01-18T14:49:59.000Z</published>
    <updated>2018-01-22T15:12:06.960Z</updated>
    
    <content type="html"><![CDATA[<h2 id="problem"><font color="black">Problem:</font></h2><blockquote><p>Given a binary tree, return the level order traversal of its nodes’ values. (ie, from left to right, level by level).</p></blockquote><h2 id="idea"><fontc color="red">Idea:</fontc></h2><p>  Here, we give two way of solve this problem, one is mark index for every level and the next is use a queue to traverse every level.</p><h2 id="java-code"><font color="orange">Java Code:</font></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Definition for a binary tree node.</div><div class="line"> * public class TreeNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     TreeNode left;</div><div class="line"> *     TreeNode right;</div><div class="line"> *     TreeNode(int x) &#123; val = x; &#125;</div><div class="line"> * &#125;</div><div class="line"> */</div><div class="line">class Solution &#123;</div><div class="line">    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</div><div class="line">        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;();</div><div class="line">        Queue&lt;TreeNode&gt;queue = new LinkedList&lt;TreeNode&gt;();</div><div class="line">        if(root == null)</div><div class="line">            return res;</div><div class="line">        queue.add(root);</div><div class="line">        while(!queue.isEmpty())&#123;</div><div class="line">            List&lt;Integer&gt; tmp = new ArrayList&lt;Integer&gt;();</div><div class="line">            int len = queue.size();</div><div class="line">            for(int i=0;i&lt;len;i++)&#123;</div><div class="line">                TreeNode node = queue.poll();</div><div class="line">                tmp.add(node.val);</div><div class="line">                if(node.left!=null)</div><div class="line">                    queue.add(node.left);</div><div class="line">                if(node.right!=null)</div><div class="line">                    queue.add(node.right);</div><div class="line">            &#125;</div><div class="line">            res.add(tmp);</div><div class="line">        &#125;</div><div class="line">        return res;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="c-code"><font color="gold">C++ Code:</font></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Definition for a binary tree node.</div><div class="line"> * struct TreeNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     TreeNode *left;</div><div class="line"> *     TreeNode *right;</div><div class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</div><div class="line"> * &#125;;</div><div class="line"> */</div><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123;</div><div class="line">        inOrder(root, 0);</div><div class="line">        return res;</div><div class="line">    &#125;</div><div class="line">    void inOrder(TreeNode* root,int depth)&#123;</div><div class="line">        if(root==NULL)</div><div class="line">            return;</div><div class="line">        if(res.size()==depth)</div><div class="line">            res.push_back(vector&lt;int&gt;());</div><div class="line">        res[depth].push_back(root-&gt;val);</div><div class="line">        inOrder(root-&gt;left,depth+1);</div><div class="line">        inOrder(root-&gt;right,depth+1);</div><div class="line">    &#125;</div><div class="line">private:</div><div class="line">    vector&lt;vector&lt;int&gt;&gt; res;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;problem&quot;&gt;&lt;font color=&quot;black&quot;&gt;Problem:&lt;/font&gt;&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Given a binary tree, return the level order traversal of its nodes
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://www.mysry.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>99. Recover Binary Search Tree</title>
    <link href="http://www.mysry.com/2018/01/18/99-Recover-Binary-Search-Tree/"/>
    <id>http://www.mysry.com/2018/01/18/99-Recover-Binary-Search-Tree/</id>
    <published>2018-01-18T14:05:04.000Z</published>
    <updated>2018-01-18T14:14:46.780Z</updated>
    
    <content type="html"><![CDATA[<h2 id="problem"><font color="black">Problem:</font></h2><blockquote><p>Two elements of a binary search tree (BST) are swapped by mistake. Recover the tree without changing its structure. Note: A solution using O(n) space is pretty straight forward. Could you devise a constant space solution?</p></blockquote><h2 id="idea"><font color="red">Idea:</font></h2><p>  Inorder traversal of binary search tree. We need to find the first number which is bigger than its follow one and the last number which is smaller than its previous one.</p><h2 id="java-code"><font color="orange">Java Code:</font></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Definition for a binary tree node.</div><div class="line"> * public class TreeNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     TreeNode left;</div><div class="line"> *     TreeNode right;</div><div class="line"> *     TreeNode(int x) &#123; val = x; &#125;</div><div class="line"> * &#125;</div><div class="line"> */</div><div class="line">class Solution &#123;</div><div class="line">    public void recoverTree(TreeNode root) &#123;</div><div class="line">        if(root==null)</div><div class="line">            return;</div><div class="line">        inOrder(root);</div><div class="line">        int tmp = first.val;</div><div class="line">        first.val = second.val;</div><div class="line">        second.val = tmp;</div><div class="line">    &#125;</div><div class="line">    public void inOrder(TreeNode root)&#123;</div><div class="line">        if(root==null)</div><div class="line">            return;</div><div class="line">        inOrder(root.left);</div><div class="line">        if(pre!=null&amp;&amp;pre.val&gt;root.val)&#123;</div><div class="line">            if(first==null)</div><div class="line">                first = pre;</div><div class="line">            second = root;</div><div class="line">        &#125;</div><div class="line">        pre = root;</div><div class="line">        inOrder(root.right);</div><div class="line">    &#125;</div><div class="line">    private TreeNode first=null;</div><div class="line">    private TreeNode second=null;</div><div class="line">    private TreeNode pre=null;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="c-code"><font color="gold">C++ Code:</font></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Definition for a binary tree node.</div><div class="line"> * struct TreeNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     TreeNode *left;</div><div class="line"> *     TreeNode *right;</div><div class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</div><div class="line"> * &#125;;</div><div class="line"> */</div><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    void recoverTree(TreeNode* root) &#123;</div><div class="line">        if(!root)</div><div class="line">            return ;</div><div class="line">        inOrder(root);</div><div class="line">        swap(first-&gt;val, second-&gt;val);</div><div class="line">    &#125;</div><div class="line">    void inOrder(TreeNode* root)&#123;</div><div class="line">        if(!root)</div><div class="line">            return;</div><div class="line">        inOrder(root-&gt;left);</div><div class="line">        if(pre&amp;&amp;pre-&gt;val&gt;root-&gt;val)&#123;</div><div class="line">            if(!first)</div><div class="line">                first = pre;</div><div class="line">            second = root;</div><div class="line">        &#125;</div><div class="line">        pre = root;</div><div class="line">        inOrder(root-&gt;right);</div><div class="line">    &#125;</div><div class="line">private:</div><div class="line">    TreeNode* pre = NULL, *first = NULL, *second = NULL;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;problem&quot;&gt;&lt;font color=&quot;black&quot;&gt;Problem:&lt;/font&gt;&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Two elements of a binary search tree (BST) are swapped by mistake.
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://www.mysry.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>98. Validate Binary Search Tree</title>
    <link href="http://www.mysry.com/2018/01/17/98-Validate-Binary-Search-Tree/"/>
    <id>http://www.mysry.com/2018/01/17/98-Validate-Binary-Search-Tree/</id>
    <published>2018-01-17T14:25:19.000Z</published>
    <updated>2018-01-17T14:30:40.689Z</updated>
    
    <content type="html"><![CDATA[<h2 id="problem"><font color="black">Problem:</font></h2><blockquote><p>Given a binary tree, determine if it is a valid binary search tree (BST). Assume a BST is defined as follows: * The left subtree of a node contains only nodes with keys less than the node’s key. * The right subtree of a node contains only nodes with keys greater than the node’s key. * Both the left and right subtrees must also be binary search trees.</p></blockquote><h2 id="idea"><font color="red">Idea:</font></h2><p>  DFS. Check every root if it is greater than left and smaller than right, then there comes two subtree, check the root of this subtree either.</p><h2 id="java-code"><font color="orange">Java Code:</font></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Definition for a binary tree node.</div><div class="line"> * public class TreeNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     TreeNode left;</div><div class="line"> *     TreeNode right;</div><div class="line"> *     TreeNode(int x) &#123; val = x; &#125;</div><div class="line"> * &#125;</div><div class="line"> */</div><div class="line">class Solution &#123;</div><div class="line">    public boolean isValidBST(TreeNode root) &#123;</div><div class="line">        return isvalid(root,null,null);</div><div class="line">    &#125;</div><div class="line">    public boolean isvalid(TreeNode root,TreeNode min,TreeNode max)&#123;</div><div class="line">        if(root == null)</div><div class="line">            return true;</div><div class="line">        if((min!=null&amp;&amp;root.val&lt;=min.val)||(max!=null&amp;&amp;root.val&gt;=max.val))</div><div class="line">            return false;</div><div class="line">        return isvalid(root.left,min,root)&amp;&amp;isvalid(root.right,root,max);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="c-code"><font color="orange">C++ Code:</font></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Definition for a binary tree node.</div><div class="line"> * struct TreeNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     TreeNode *left;</div><div class="line"> *     TreeNode *right;</div><div class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</div><div class="line"> * &#125;;</div><div class="line"> */</div><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    bool isValidBST(TreeNode* root) &#123;</div><div class="line">        return isvalid(root,NULL,NULL);</div><div class="line">    &#125;</div><div class="line">    bool isvalid(TreeNode* root,TreeNode* min, TreeNode* max)</div><div class="line">    &#123;</div><div class="line">        if(root==NULL)</div><div class="line">            return true;</div><div class="line">        if((min!=NULL&amp;&amp;root-&gt;val&lt;=min-&gt;val)||(max!=NULL&amp;&amp;root-&gt;val&gt;=max-&gt;val))</div><div class="line">            return false;</div><div class="line">        return isvalid(root-&gt;left,min,root)&amp;&amp;isvalid(root-&gt;right,root,max);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;problem&quot;&gt;&lt;font color=&quot;black&quot;&gt;Problem:&lt;/font&gt;&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Given a binary tree, determine if it is a valid binary search tree
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://www.mysry.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>97. Interleaving String</title>
    <link href="http://www.mysry.com/2018/01/17/97-Interleaving-String/"/>
    <id>http://www.mysry.com/2018/01/17/97-Interleaving-String/</id>
    <published>2018-01-17T13:52:56.000Z</published>
    <updated>2018-01-17T14:06:26.939Z</updated>
    
    <content type="html"><![CDATA[<h2 id="problem"><font color="black">Problem:</font></h2><blockquote><p>Given s1, s2, s3, find whether s3 is formed by the interleaving of s1 and s2.</p></blockquote><h2 id="idea"><font color="red">Idea:</font></h2><p>  The main idea of this problem could be dynamic programming. So we can expand s1 and s2 to be a matrix, if we could find a path from start point to <code>matrix[len1][len2]</code> with all step were true, that means valid.</p><h2 id="java-code"><font color="orange">Java Code:</font></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">    public boolean isInterleave(String s1, String s2, String s3) &#123;</div><div class="line">        int len1 = s1.length(), len2 = s2.length(), len3 = s3.length();</div><div class="line">        if(len1+len2!=len3)</div><div class="line">            return false;</div><div class="line">        char[] S1 = s1.toCharArray();</div><div class="line">        char[] S2 = s2.toCharArray();</div><div class="line">        char[] S3 = s3.toCharArray();</div><div class="line">        boolean[][] map = new boolean[len1+1][len2+1];</div><div class="line">        for(int i =0;i&lt;=len1;i++)&#123;</div><div class="line">            for(int j=0;j&lt;=len2;j++)&#123;</div><div class="line">                if(i==0&amp;&amp;j==0)</div><div class="line">                    map[i][j]=true;</div><div class="line">                else if(i==0)</div><div class="line">                    map[i][j]=map[i][j-1]&amp;S3[i+j-1]==S2[j-1];</div><div class="line">                else if(j==0)</div><div class="line">                    map[i][j]=map[i-1][j]&amp;S3[i+j-1]==S1[i-1];</div><div class="line">                else</div><div class="line">                    map[i][j]=(map[i][j-1]&amp;S3[i+j-1]==S2[j-1])|(map[i-1][j]&amp;S3[i+j-1]==S1[i-1]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return map[len1][len2];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="c-code"><font color="gold">C++ Code:</font></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    bool isInterleave(string s1, string s2, string s3) &#123;</div><div class="line">        int len1 = s1.size(), len2 = s2.size(), len3 = s3.size();</div><div class="line">        if(len1+len2!=len3)</div><div class="line">            return false;</div><div class="line">        vector&lt;vector&lt;bool&gt; &gt; map(len1 + 1,vector&lt;bool&gt;(len2 + 1, false));</div><div class="line">        for(int i = 0;i&lt;= len1;i++)&#123;</div><div class="line">            for(int j = 0;j&lt;=len2;j++)&#123;</div><div class="line">                if(i==0&amp;&amp;j==0)</div><div class="line">                    map[i][j]=true;</div><div class="line">                else if(i==0)</div><div class="line">                    map[i][j]=map[i][j-1]&amp;s3[i+j-1]==s2[j-1];</div><div class="line">                else if(j==0)</div><div class="line">                    map[i][j]=map[i-1][j]&amp;s3[i+j-1]==s1[i-1];</div><div class="line">                else</div><div class="line">                    map[i][j]=(map[i][j-1]&amp;s3[i+j-1]==s2[j-1])|(map[i-1][j]&amp;s3[i+j-1]==s1[i-1]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return map[len1][len2];</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;problem&quot;&gt;&lt;font color=&quot;black&quot;&gt;Problem:&lt;/font&gt;&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Given s1, s2, s3, find whether s3 is formed by the interleaving of
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://www.mysry.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>96. Unique Binary Search Trees</title>
    <link href="http://www.mysry.com/2018/01/16/96-Unique-Binary-Search-Trees/"/>
    <id>http://www.mysry.com/2018/01/16/96-Unique-Binary-Search-Trees/</id>
    <published>2018-01-16T13:39:36.000Z</published>
    <updated>2018-01-16T13:45:49.195Z</updated>
    
    <content type="html"><![CDATA[<h2 id="problem"><font color="black">Problem:</font></h2><blockquote><p>Given n, how many structurally unique BST’s (binary search trees) that store values 1…n?</p></blockquote><h2 id="idea"><font color="red">Idea:</font></h2><p>  This problem is called catalan, for that it have the rules:<span class="math display">\[h(0)=h(1)=1\]</span> <span class="math display">\[h(n)=h(0)+h(n-1)+\cdots+h(n-1)h(0)\]</span>It can be smplified as:$$h(n)=(4n-2)/((n+1)*h(n-1))</p><h2 id="java-code"><font color="orange">Java Code:</font></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">    public int numTrees(int n) &#123;</div><div class="line">        int [] G = new int[n+1];</div><div class="line">        G[0] = G[1] = 1;</div><div class="line">        for(int i=2; i&lt;=n; ++i) &#123;</div><div class="line">        for(int j=1; j&lt;=i; ++j) &#123;</div><div class="line">        G[i] += G[j-1] * G[i-j];</div><div class="line">        &#125;</div><div class="line">        &#125;</div><div class="line">        return G[n];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="c-code"><font color="gold">C++ Code:</font></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int numTrees(int n) &#123;</div><div class="line">    long long ans=1,i;</div><div class="line">    for(i=1;i&lt;=n;i++)</div><div class="line">        ans = ans*(i+n)/i;</div><div class="line">    return ans/i;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;problem&quot;&gt;&lt;font color=&quot;black&quot;&gt;Problem:&lt;/font&gt;&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Given n, how many structurally unique BST’s (binary search trees) 
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://www.mysry.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>95. Unique Binary Search Trees II</title>
    <link href="http://www.mysry.com/2018/01/13/95-Unique-Binary-Search-Trees-II/"/>
    <id>http://www.mysry.com/2018/01/13/95-Unique-Binary-Search-Trees-II/</id>
    <published>2018-01-13T01:58:12.000Z</published>
    <updated>2018-01-13T02:38:48.710Z</updated>
    
    <content type="html"><![CDATA[<h2 id="problem"><font color="black">Problem:</font></h2><blockquote><p>Given an integer n, generate all structurally unique BST’s (binary search trees) that store values 1…n.</p></blockquote><h2 id="idea"><font color="red">Idea:</font></h2><p>  Traverse the sequence from 1 to n, set every num i to be the root node, and the left subtree is (1,i-1), right subtree is (i+1,n), then construct the new subtree.</p><h2 id="java-code"><font color="orange">Java Code:</font></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Definition for a binary tree node.</div><div class="line"> * public class TreeNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     TreeNode left;</div><div class="line"> *     TreeNode right;</div><div class="line"> *     TreeNode(int x) &#123; val = x; &#125;</div><div class="line"> * &#125;</div><div class="line"> */</div><div class="line">class Solution &#123;</div><div class="line">    public List&lt;TreeNode&gt; generateTrees(int n) &#123;</div><div class="line">        if(n==0)&#123;</div><div class="line">            return new ArrayList&lt;TreeNode&gt;();</div><div class="line">        &#125;</div><div class="line">        else</div><div class="line">            return genTree(1,n);</div><div class="line">    &#125;</div><div class="line">    public List&lt;TreeNode&gt; genTree(int start,int end)&#123;</div><div class="line">        List&lt;TreeNode&gt; res = new ArrayList&lt;TreeNode&gt;();</div><div class="line">        if(start&gt;end)&#123;</div><div class="line">            res.add(null);</div><div class="line">        &#125;</div><div class="line">        for (int i = start ;i&lt;=end;i++)&#123;</div><div class="line">            List&lt;TreeNode&gt; leftNode = genTree(start,i-1);</div><div class="line">            List&lt;TreeNode&gt; rightNode = genTree(i+1,end);</div><div class="line">            for (TreeNode left:leftNode)&#123;</div><div class="line">                for (TreeNode right:rightNode)&#123;</div><div class="line">                    TreeNode root = new TreeNode(i);</div><div class="line">                    root.left = left;</div><div class="line">                    root.right = right;</div><div class="line">                    res.add(root);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return res;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="c-code"><font color="gold">C++ Code:</font></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Definition for a binary tree node.</div><div class="line"> * struct TreeNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     TreeNode *left;</div><div class="line"> *     TreeNode *right;</div><div class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</div><div class="line"> * &#125;;</div><div class="line"> */</div><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    vector&lt;TreeNode*&gt; generateTrees(int n) &#123;</div><div class="line">        if(n==0)</div><div class="line">            return vector&lt;TreeNode*&gt;();</div><div class="line">        else</div><div class="line">            return genTree(1,n);</div><div class="line">    &#125;</div><div class="line">    vector&lt;TreeNode*&gt; genTree(int start,int end)&#123;</div><div class="line">        vector&lt;TreeNode*&gt; res;</div><div class="line">        if(start&gt;end)</div><div class="line">            res.push_back(NULL);</div><div class="line">        vector&lt;TreeNode*&gt;leftList,rightList;</div><div class="line">        for (int i = start ;i&lt;= end;i++)&#123;</div><div class="line">            leftList = genTree(start,i-1);</div><div class="line">            rightList = genTree(i+1,end);</div><div class="line">            for(auto left:leftList)&#123;</div><div class="line">                for( auto right:rightList)&#123;</div><div class="line">                    TreeNode* root = new TreeNode(i);</div><div class="line">                    root-&gt;left = left;</div><div class="line">                    root-&gt;right = right;</div><div class="line">                    res.push_back(root);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;problem&quot;&gt;&lt;font color=&quot;black&quot;&gt;Problem:&lt;/font&gt;&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Given an integer n, generate all structurally unique BST’s (binary
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://www.mysry.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>94. Binary Tree Inorder Traversal</title>
    <link href="http://www.mysry.com/2018/01/10/94-Binary-Tree-Inorder-Traversal/"/>
    <id>http://www.mysry.com/2018/01/10/94-Binary-Tree-Inorder-Traversal/</id>
    <published>2018-01-10T14:45:52.000Z</published>
    <updated>2018-01-10T14:52:02.075Z</updated>
    
    <content type="html"><![CDATA[<h2 id="problem"><font color="black">Problem:</font></h2><blockquote><p>Given a binary tree, return the inorder traversal of its nodes’ values. Note: Recursive solution is trivial, could you do it iteratively?</p></blockquote><h2 id="idea"><font color="red">Idea:</font></h2><p>  Inorder traver and without recursion! we’d like to search every left branch and push it into stack untile the leaf node. The take one by one out of the stack, switch to next branch.</p><h2 id="java-code"><font color="orange">Java Code:</font></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Definition for a binary tree node.</div><div class="line"> * public class TreeNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     TreeNode left;</div><div class="line"> *     TreeNode right;</div><div class="line"> *     TreeNode(int x) &#123; val = x; &#125;</div><div class="line"> * &#125;</div><div class="line"> */</div><div class="line">class Solution &#123;</div><div class="line">    public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;</div><div class="line">        List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</div><div class="line">        TreeNode[] stack = new TreeNode[1000];</div><div class="line">        int index = 0;</div><div class="line">        TreeNode p = root;</div><div class="line">        while (p != null || index &gt; 0) &#123;</div><div class="line">            if(p!=null)&#123;</div><div class="line">                stack[index++] = p;</div><div class="line">                p = p.left;</div><div class="line">            &#125;else&#123;</div><div class="line">                p = stack[--index];</div><div class="line">                list.add(p.val);</div><div class="line">                p = p.right;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return list;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="c-code"><font color="gold">C++ Code:</font></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Definition for a binary tree node.</div><div class="line"> * struct TreeNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     TreeNode *left;</div><div class="line"> *     TreeNode *right;</div><div class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</div><div class="line"> * &#125;;</div><div class="line"> */</div><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123;</div><div class="line">        vector&lt;int&gt; res;</div><div class="line">        stack&lt;TreeNode*&gt; tmp;</div><div class="line">        while(!tmp.empty()||root!=NULL)&#123;</div><div class="line">            if(root!=NULL)&#123;</div><div class="line">                tmp.push(root);</div><div class="line">                root = root-&gt;left;</div><div class="line">            &#125;</div><div class="line">            else&#123;</div><div class="line">                root = tmp.top();</div><div class="line">                res.push_back((tmp.top())-&gt;val);</div><div class="line">                tmp.pop();</div><div class="line">                root = root-&gt;right;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;problem&quot;&gt;&lt;font color=&quot;black&quot;&gt;Problem:&lt;/font&gt;&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Given a binary tree, return the inorder traversal of its nodes’ va
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://www.mysry.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>93. Restore IP Addresses</title>
    <link href="http://www.mysry.com/2018/01/08/93-Restore-IP-Addresses/"/>
    <id>http://www.mysry.com/2018/01/08/93-Restore-IP-Addresses/</id>
    <published>2018-01-08T14:44:12.000Z</published>
    <updated>2018-01-08T14:50:26.923Z</updated>
    
    <content type="html"><![CDATA[<h2 id="problem"><font color="black">Problem:</font></h2><blockquote><p>Given a string containing only digits, restore it by returning all possible valid IP address combinations.</p></blockquote><h2 id="idea"><font color="red">Idea:</font></h2><p> Oops!! It’s really good for the examination week has passed and so I can do things what I like now! For this problem, add for dot in the digits and check if it is valid!</p><h2 id="java-code"><font color="orange">Java Code:</font></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">    public List&lt;String&gt; restoreIpAddresses(String s) &#123;</div><div class="line">        List&lt;String&gt; res = new ArrayList&lt;String&gt;();</div><div class="line">        int len = s.length();</div><div class="line">        for(int i = 1;i&lt;4;i++)&#123;</div><div class="line">            for(int j = i+1;j&lt;i+4 &amp;&amp; j&lt;len-1;j++)&#123;</div><div class="line">                for(int k = j+1;k&lt;j+4&amp;&amp;k&lt;len;k++)&#123;</div><div class="line">                    String s1 = s.substring(0,i), s2 = s.substring(i,j), s3 = s.substring(j,k), s4 = s.substring(k,len);</div><div class="line">                    if(isValid(s1)&amp;&amp;isValid(s2)&amp;&amp;isValid(s3)&amp;&amp;isValid(s4))</div><div class="line">                        res.add(s1+&apos;.&apos;+s2+&apos;.&apos;+s3+&apos;.&apos;+s4);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return res;</div><div class="line">    &#125;</div><div class="line">    public boolean isValid(String s)&#123;</div><div class="line">        if(s.length()&gt;3||s.length()==0||(s.charAt(0)==&apos;0&apos;&amp;&amp;s.length()&gt;1)||Integer.parseInt(s)&gt;255)</div><div class="line">            return false;</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="c-code"><font color="orange">C++ Code:</font></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    vector&lt;string&gt; restoreIpAddresses(string s) &#123;</div><div class="line">        vector&lt;string&gt; res;</div><div class="line">        int len = s.size();</div><div class="line">        for(int i = 1;i&lt;4;i++)&#123;</div><div class="line">            for(int j = i+1;j&lt;i+4&amp;&amp;j&lt;len-1;j++)&#123;</div><div class="line">                for(int k = j+1; k&lt;j+4&amp;&amp;k&lt;len;k++)&#123;</div><div class="line">                    string s1 = s.substr(0,i),s2 = s.substr(i,j-i), s3 = s.substr(j,k-j), s4 = s.substr(k,len-k);</div><div class="line">                    if(isValid(s1)&amp;&amp;isValid(s2)&amp;&amp;isValid(s3)&amp;&amp;isValid(s4))&#123;</div><div class="line">                        string tmp = s1+&apos;.&apos;+s2+&apos;.&apos;+s3+&apos;.&apos;+s4;</div><div class="line">                        res.push_back(tmp);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return res;</div><div class="line">    &#125;</div><div class="line">   bool isValid(string s)&#123;</div><div class="line">        if ((s[0] == &apos;0&apos; &amp;&amp; s.size() &gt; 1)||s.size()&gt;3||(s.size()==3&amp;&amp;s&gt;&quot;255&quot;))</div><div class="line">            return false;</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;problem&quot;&gt;&lt;font color=&quot;black&quot;&gt;Problem:&lt;/font&gt;&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Given a string containing only digits, restore it by returning all
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://www.mysry.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>92. Reverse Linked List II</title>
    <link href="http://www.mysry.com/2017/12/19/92-Reverse-Linked-List-II/"/>
    <id>http://www.mysry.com/2017/12/19/92-Reverse-Linked-List-II/</id>
    <published>2017-12-19T14:39:49.000Z</published>
    <updated>2017-12-19T14:45:58.985Z</updated>
    
    <content type="html"><![CDATA[<h2 id="problem"><font color="black">Problem:</font></h2><blockquote><p>Reverse a linked list from position m to n. Do it in-place and in one-pass.</p></blockquote><h2 id="idea"><font color="red">Idea:</font></h2><p> From m node, set <code>cur</code> to be the immediate node after <code>pre</code> and at each time move the immediate node after <code>cur</code> (named move) to be the immediate node after <code>pre</code>. Repeat it for n - m times.</p><h2 id="java-code"><font color="orange">Java Code:</font></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Definition for singly-linked list.</div><div class="line"> * public class ListNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     ListNode next;</div><div class="line"> *     ListNode(int x) &#123; val = x; &#125;</div><div class="line"> * &#125;</div><div class="line"> */</div><div class="line">class Solution &#123;</div><div class="line">    public ListNode reverseBetween(ListNode head, int m, int n) &#123;</div><div class="line">        ListNode dummy = new ListNode(0);</div><div class="line">        dummy.next = head;</div><div class="line">        ListNode subtail = new ListNode(0);</div><div class="line">        ListNode subhead = new ListNode(0);</div><div class="line">        int count =1;</div><div class="line">        ListNode pre_cur = dummy,cur = head;</div><div class="line">        while(count&lt;=n)&#123;</div><div class="line">            ListNode tmp = cur.next;</div><div class="line">            if(count&lt;m)&#123;</div><div class="line">                pre_cur = cur;</div><div class="line">            &#125;</div><div class="line">            else if (count ==m)&#123;</div><div class="line">                subtail = cur;</div><div class="line">                subhead.next = cur;</div><div class="line">            &#125;else&#123;</div><div class="line">                cur.next = subhead.next;</div><div class="line">                subhead.next = cur;</div><div class="line">            &#125;</div><div class="line">            cur = tmp;</div><div class="line">            ++count;</div><div class="line">        &#125;</div><div class="line">        pre_cur.next = subhead.next;</div><div class="line">        subtail.next = cur;</div><div class="line">        return dummy.next;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="c-code"><font color="gold">C++ Code:</font></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Definition for singly-linked list.</div><div class="line"> * struct ListNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     ListNode *next;</div><div class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</div><div class="line"> * &#125;;</div><div class="line"> */</div><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    ListNode* reverseBetween(ListNode* head, int m, int n) &#123;</div><div class="line">        ListNode* newhead = new ListNode(0);</div><div class="line">        newhead-&gt;next = head;</div><div class="line">        ListNode* pre = newhead;</div><div class="line">        for (int i=0;i&lt;m-1;i++)</div><div class="line">            pre = pre-&gt;next;</div><div class="line">        ListNode* cur = pre-&gt;next;</div><div class="line">        for (int i=0;i&lt;n-m;i++)&#123;</div><div class="line">            ListNode* tmp = cur-&gt;next;</div><div class="line">            cur-&gt;next = tmp-&gt;next;</div><div class="line">            tmp-&gt;next = pre-&gt;next;</div><div class="line">            pre-&gt;next = tmp;</div><div class="line">        &#125;</div><div class="line">        return newhead-&gt;next;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;problem&quot;&gt;&lt;font color=&quot;black&quot;&gt;Problem:&lt;/font&gt;&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Reverse a linked list from position m to n. Do it in-place and in 
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://www.mysry.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>91. Decode Ways</title>
    <link href="http://www.mysry.com/2017/12/18/91-Decode-Ways/"/>
    <id>http://www.mysry.com/2017/12/18/91-Decode-Ways/</id>
    <published>2017-12-18T14:02:38.000Z</published>
    <updated>2017-12-18T14:07:03.245Z</updated>
    
    <content type="html"><![CDATA[<h2 id="problem"><font color="black">Problem:</font></h2><blockquote><p>A message containing letters from A-Z is being encoded to numbers using the following mapping: ‘A’ -&gt; 1 ‘B’ -&gt; 2 … ‘Z’ -&gt; 26 Given an encoded message containing digits, determine the total number of ways to decode it.</p></blockquote><h2 id="idea"><font color="orange">Idea:</font></h2><p> Use the Dp method and there are three conditions for this problem.</p><h2 id="java-code"><font color="orange">Java Code:</font></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">    public int numDecodings(String s) &#123;</div><div class="line">        int size = s.length();</div><div class="line">        char[] t=s.toCharArray();</div><div class="line">        if(size&lt;=0||t[0]==&apos;0&apos;)</div><div class="line">            return 0;</div><div class="line">        int[] dp=new int[size+1];</div><div class="line">        dp[0]=dp[1]=1;</div><div class="line">        for(int i=1;i&lt;size;++i)&#123;</div><div class="line">            if(t[i]==&apos;0&apos;)</div><div class="line">                dp[i]=0;</div><div class="line">            if(t[i-1]==&apos;1&apos;||t[i-1]&lt;=&apos;2&apos;&amp;&amp;t[i]&lt;=&apos;6&apos;)</div><div class="line">                dp[i+1] = dp[i]+dp[i-1];</div><div class="line">            else</div><div class="line">                dp[i+1]=dp[i];</div><div class="line">        &#125;</div><div class="line">        return dp[size];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="c-code"><font color="gold">C++ Code:</font></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int numDecodings(string s) &#123;</div><div class="line">        int size = s.size();</div><div class="line">        if(size&lt;=0||s[0]==&apos;0&apos;)</div><div class="line">            return 0;</div><div class="line">        vector&lt;int&gt; dp(size+1,0);</div><div class="line">        dp[0]=dp[1]=1;</div><div class="line">        for(int i=1;i&lt;size;++i)&#123;</div><div class="line">            if(s[i]==&apos;0&apos;)</div><div class="line">                dp[i]=0;</div><div class="line">            if(s[i-1]==&apos;1&apos;||s[i-1]&lt;=&apos;2&apos;&amp;&amp;s[i]&lt;=&apos;6&apos;)</div><div class="line">                dp[i+1] = dp[i]+dp[i-1];</div><div class="line">            else</div><div class="line">                dp[i+1]=dp[i];</div><div class="line">        &#125;</div><div class="line">        return dp[size];</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;problem&quot;&gt;&lt;font color=&quot;black&quot;&gt;Problem:&lt;/font&gt;&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;A message containing letters from A-Z is being encoded to numbers 
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://www.mysry.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>90. Subsets II</title>
    <link href="http://www.mysry.com/2017/12/18/90-Subsets-II/"/>
    <id>http://www.mysry.com/2017/12/18/90-Subsets-II/</id>
    <published>2017-12-18T12:46:49.000Z</published>
    <updated>2017-12-18T12:52:43.120Z</updated>
    
    <content type="html"><![CDATA[<h2 id="problem"><font color="black">Problem:</font></h2><blockquote><p>Given a collection of integers that might contain duplicates, nums, return all possible subsets (the power set). Note: The solution set must not contain duplicate subsets.</p></blockquote><h2 id="idea"><font color="red">Idea:</font></h2><p> This problem is following up <a href="http://www.mysry.com/2017/12/08/78-Subsets/">subsets</a>. But there is one more condition of duplicates. Also bfs + backtracking.</p><h2 id="java-code"><font color="orange">Java Code:</font></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">    public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) &#123;</div><div class="line">        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;();</div><div class="line">        List&lt;Integer&gt;tmp = new ArrayList&lt;Integer&gt;();</div><div class="line">        Arrays.sort(nums);</div><div class="line">        dfs(res,tmp,nums,0);</div><div class="line">        return res;</div><div class="line">    &#125;</div><div class="line">    public void dfs(List&lt;List&lt;Integer&gt;&gt; res,List&lt;Integer&gt; tmp,int[] nums, int pos)&#123;</div><div class="line">        res.add(new ArrayList&lt;&gt;(tmp));</div><div class="line">        for(int i = pos;i&lt;nums.length;++i)&#123;</div><div class="line">            if(i==pos||nums[i]!=nums[i-1])&#123;</div><div class="line">                tmp.add(nums[i]);</div><div class="line">                dfs(res,tmp,nums,i+1);</div><div class="line">                tmp.remove(tmp.size()-1);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="c-code"><font color="gold">C++ Code:</font></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    vector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt;&amp; nums) &#123;</div><div class="line">        vector&lt;vector&lt;int&gt;&gt; res;</div><div class="line">        vector&lt;int&gt;tmp;</div><div class="line">        sort(nums.begin(),nums.end());</div><div class="line">        dfs(res,tmp,nums,0);</div><div class="line">        return res;</div><div class="line">    &#125;</div><div class="line">    void dfs(vector&lt;vector&lt;int&gt;&gt;&amp;res,vector&lt;int&gt;&amp;tmp,vector&lt;int&gt;&amp; nums, int pos)&#123;</div><div class="line">        res.push_back(tmp);</div><div class="line">        for(int i=pos;i&lt;nums.size();++i)&#123;</div><div class="line">            if(i==pos||nums[i]!=nums[i-1])&#123;</div><div class="line">                tmp.push_back(nums[i]);</div><div class="line">                dfs(res,tmp,nums,i+1);</div><div class="line">                tmp.pop_back();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;problem&quot;&gt;&lt;font color=&quot;black&quot;&gt;Problem:&lt;/font&gt;&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Given a collection of integers that might contain duplicates, nums
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://www.mysry.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>89. Gray Code</title>
    <link href="http://www.mysry.com/2017/12/17/89-Gray-Code/"/>
    <id>http://www.mysry.com/2017/12/17/89-Gray-Code/</id>
    <published>2017-12-17T14:35:40.000Z</published>
    <updated>2017-12-17T14:41:00.207Z</updated>
    
    <content type="html"><![CDATA[<h2 id="problem"><font color="black">Problem:</font></h2><blockquote><p>The gray code is a binary numeral system where two successive values differ in only one bit. Given a non-negative integer n representing the total number of bits in the code, print the sequence of gray code. A gray code sequence must begin with 0.</p></blockquote><h2 id="idea"><font color="red">Idea:</font></h2><p>  Different methods to generate Gray Code makes different solution, for instance the Gray Code can be generated by G(n) = B(n)^(B(N)/2) or mirror arrangement.</p><h2 id="java-code"><font color="orange">Java Code:</font></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">    public List&lt;Integer&gt; grayCode(int n) &#123;</div><div class="line">        List&lt;Integer&gt; res = new LinkedList&lt;&gt;();</div><div class="line">        for (int i=0;i&lt;1&lt;&lt;n;i++)</div><div class="line">            res.add(i^i&gt;&gt;1);</div><div class="line">        return res;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="c-code"><font color="gold">C++ Code:</font></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    vector&lt;int&gt; grayCode(int n) &#123;</div><div class="line">        vector&lt;int&gt; res(1,0);</div><div class="line">        for(int i = 0; i &lt; n; i++)</div><div class="line">        &#123;</div><div class="line">            int high = 1&lt;&lt;i, len = res.size();</div><div class="line">            for(int j = len-1; j &gt;=0; j--)</div><div class="line">                res.push_back(high+res[j]);</div><div class="line">        &#125;</div><div class="line">        return result;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;problem&quot;&gt;&lt;font color=&quot;black&quot;&gt;Problem:&lt;/font&gt;&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;The gray code is a binary numeral system where two successive valu
      
    
    </summary>
    
    
      <category term="leetcode" scheme="http://www.mysry.com/tags/leetcode/"/>
    
  </entry>
  
</feed>
